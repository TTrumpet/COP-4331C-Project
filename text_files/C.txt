static inline
char *ipv4_subnet_str(char *b, ip_addr_range_t *range)
{
	int idx;
	int len;
	for (idx = 0; idx < 32; idx++)
		if (range->mask & (1 << idx))
			break;
	len = 32 - idx;
	sprintf(b, "%03d.%03d.%03d.%03d/%d",
		0xFF & ((range->addr) >> 24),
		0xFF & ((range->addr) >> 16),
		0xFF & ((range->addr) >>  8),
		0xFF & ((range->addr) >>  0),
		len);
	return b;
}
void
rb_hpricot_token(hpricot_state *S, VALUE sym, VALUE tag, VALUE attr, char *raw, int rawlen, int taint)
{
  VALUE ele, ec = Qnil;
   in html mode, fix up start tags incorrectly formed as empty tags
  if (!S->xml) {
    if (sym == sym_emptytag || sym == sym_stag || sym == sym_etag) {
      ec = rb_hash_aref(S->EC, tag);
      if (NIL_P(ec)) {
        tag = rb_funcall(tag, s_downcase, 0);
        ec = rb_hash_aref(S->EC, tag);
      }
    }
    if (H_ELE_GET(S->focus, H_ELE_EC) == sym_CDATA &&
       (sym != sym_procins && sym != sym_comment && sym != sym_cdata && sym != sym_text) &&
      !(sym == sym_etag && INT2FIX(rb_str_hash(tag)) == H_ELE_GET(S->focus, H_ELE_HASH)))
    {
      sym = sym_text;
      tag = rb_str_new(raw, rawlen);
    }
    if (!NIL_P(ec)) {
      if (sym == sym_emptytag) {
        if (ec != sym_EMPTY)
          sym = sym_stag;
      } else if (sym == sym_stag) {
        if (ec == sym_EMPTY)
          sym = sym_emptytag;
      }
    }
  }
  if (sym == sym_emptytag || sym == sym_stag) {
    VALUE name = INT2FIX(rb_str_hash(tag));
    H_ELE(cElem);
    H_ELE_SET(ele, H_ELE_HASH, name);
    if (!S->xml) {
      VALUE match = Qnil, e = S->focus;
      while (e != S->doc)
      {
        VALUE hEC = H_ELE_GET(e, H_ELE_EC);
        if (TYPE(hEC) == T_HASH)
        {
          VALUE has = rb_hash_lookup(hEC, name);
          if (has != Qnil) {
            if (has == Qtrue) {
              if (match == Qnil)
                match = e;
            } else if (has == symAllow) {
              match = S->focus;
            } else if (has == symDeny) {
              match = Qnil;
            }
          }
        }
        e = H_ELE_GET(e, H_ELE_PARENT);
      }
      if (match == Qnil)
        match = S->focus;
      S->focus = match;
    }
    rb_hpricot_add(S->focus, ele);
     in the case of a start tag that should be empty, just
     skip the step that focuses the element.  focusing moves
     us deeper into the document.
    if (sym == sym_stag) {
      if (S->xml || ec != sym_EMPTY) {
        S->focus = ele;
        S->last = Qnil;
      }
    }
  } else if (sym == sym_etag) {
    VALUE name, match = Qnil, e = S->focus;
    if (S->strict) {
      if (NIL_P(rb_hash_aref(S->EC, tag))) {
        tag = rb_str_new2("div");
      }
    }
     another optimization will be to improve this very simple
     O(n) tag search, where n is the depth of the focused tag.
     (see also: the search above for fixups)
    name = INT2FIX(rb_str_hash(tag));
    while (e != S->doc)
    {
      if (H_ELE_GET(e, H_ELE_HASH) == name)
      {
        match = e;
        break;
      }
      e = H_ELE_GET(e, H_ELE_PARENT);
    }
    if (NIL_P(match))
    {
      H_ELE(cBogusETag);
      rb_hpricot_add(S->focus, ele);
    }
    else
    {
      VALUE ele = Qnil;
      if (raw != NULL)
        ele = rb_str_new(raw, rawlen);
      H_ELE_SET(match, H_ELE_ETAG, ele);
      S->focus = H_ELE_GET(match, H_ELE_PARENT);
      S->last = Qnil;
    }
  } else if (sym == sym_cdata) {
    H_ELE(cCData);
    rb_hpricot_add(S->focus, ele);
  } else if (sym == sym_comment) {
    H_ELE(cComment);
    rb_hpricot_add(S->focus, ele);
  } else if (sym == sym_doctype) {
    H_ELE(cDocType);
    if (S->strict) {
      rb_hash_aset(attr, ID2SYM(rb_intern("system_id")), rb_str_new2("http:www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"));
      rb_hash_aset(attr, ID2SYM(rb_intern("public_id")), rb_str_new2("-W3CDTD XHTML 1.0 StrictEN"));
    }
    rb_hpricot_add(S->focus, ele);
  } else if (sym == sym_procins) {
    VALUE match = rb_funcall(tag, rb_intern("match"), 1, reProcInsParse);
    tag = rb_reg_nth_match(1, match);
    attr = rb_reg_nth_match(2, match);
    {
      H_ELE(cProcIns);
      rb_hpricot_add(S->focus, ele);
    }
  } else if (sym == sym_text) {
     TODO: add raw_string as well?
    if (!NIL_P(S->last) && RBASIC(S->last)->klass == cText) {
      rb_str_append(H_ELE_GET(S->last, H_ELE_TAG), tag);
    } else {
      H_ELE(cText);
      rb_hpricot_add(S->focus, ele);
    }
  } else if (sym == sym_xmldecl) {
    H_ELE(cXMLDecl);
    rb_hpricot_add(S->focus, ele);
  }
}
static int
eth_dev_get_hash_mac_addr_index(uint16_t port_id,
		const struct rte_ether_addr *addr)
{
	struct rte_eth_dev_info dev_info;
	struct rte_eth_dev *dev = &rte_eth_devices[port_id];
	unsigned i;
	int ret;
	ret = rte_eth_dev_info_get(port_id, &dev_info);
	if (ret != 0)
		return -1;
	if (!dev->data->hash_mac_addrs)
		return -1;
	for (i = 0; i < dev_info.max_hash_mac_addrs; i++)
		if (memcmp(addr, &dev->data->hash_mac_addrs[i],
			RTE_ETHER_ADDR_LEN) == 0)
			return i;
	return -1;
}
static int
unexpected_err(IMB_MGR *mgr, const IMB_ERR expected_err, const char *func_desc)
{
        const IMB_ERR err = imb_get_errno(mgr);
        if (err != expected_err) {
                printf("%s error: expected %s, got %s\n", func_desc,
                       imb_get_strerror(expected_err), imb_get_strerror(err));
                return 1;
        }
        return 0;
}
static void PmSystemCheckTcm(void)
{
	u32 i;
	for (i = 0U; i < ARRAY_SIZE(pmSystemTcmSlaves); i++) {
		PmSlave* slave = &pmSystemTcmSlaves[i]->sram.slv;
		PmRequirement* req = slave->reqs;
		bool save = false;
		while (NULL != req) {
			PmMaster* master = req->master;
			if (NULL != master) {
				if (PmMasterIsSuspended(master)) {
					if (0U != req->currReq) {
						save = true;
						break;
					}
				} else if (PmMasterIsSuspending(master)) {
					if (0U != req->nextReq) {
						save = true;
						break;
					}
				} else {
				}
			}
			req = req->nextMaster;
		}
		if (true == save) {
			PmSystemSetPosRequirement(slave, PM_CAP_ACCESS);
			PmSystemTcmSetSave(pmSystemTcmSlaves[i]->base,
					   TCM_SAVE_MEMORY);
		} else {
			PmSystemSetPosRequirement(slave, 0U);
			PmSystemTcmSetSave(pmSystemTcmSlaves[i]->base,
					   TCM_SKIP_MEMORY);
		}
	}
}
int32_t
ulp_rte_count_act_handler(const struct rte_flow_action *action_item,
			  struct ulp_rte_parser_params *params)
{
	const struct rte_flow_action_count *act_count;
	struct ulp_rte_act_prop *act_prop = &params->act_prop;
	act_count = action_item->conf;
	if (act_count) {
		if (act_count->shared) {
			BNXT_TF_DBG(ERR,
				    "Parse Error:Shared count not supported\n");
			return BNXT_TF_RC_PARSE_ERR;
		}
		memcpy(&act_prop->act_details[BNXT_ULP_ACT_PROP_IDX_COUNT],
		       &act_count->id,
		       BNXT_ULP_ACT_PROP_SZ_COUNT);
	}
	ULP_BITMAP_SET(params->act_bitmap.bits, BNXT_ULP_ACTION_BIT_COUNT);
	return BNXT_TF_RC_SUCCESS;
}
void
kk_player_event_seek (kk_event_queue_t *queue, float perc)
{
  kk_player_event_seek_t event;
  memset (&event, 0, sizeof (kk_player_event_seek_t));
  event.type = KK_PLAYER_SEEK;
  event.perc = perc;
  kk_event_queue_write (queue, (void *) &event, sizeof (kk_player_event_seek_t));
}
int lua_GetCollisionRayModel(lua_State *L)
{
    Ray ray = LuaGetArgument_Ray(L, 1);
    Model model = LuaGetArgument_Model(L, 2);
    RayHitInfo result = GetCollisionRayModel(ray, model);
    LuaPush_RayHitInfo(L, result);
    return 1;
}
bool is_message_type_set(JCR *jcr, int type)
{
   MSGS *msgs = NULL;
   if (jcr) {
       msgs = jcr->jcr_msgs;
   }
   if (!msgs) {
      msgs = daemon_msgs;            
   }
   if (msgs && (type != M_ABORT && type != M_ERROR_TERM) &&
       !bit_is_set(type, msgs->send_msg)) {
      return false;                 
   }
   return true;
}
static int CVSpgmrPSolve(void *cvode_mem, N_Vector r, N_Vector z, int lr)
{
  CVodeMem   cv_mem;
  CVSpgmrMem cvspgmr_mem;
  int ier;
  cv_mem = (CVodeMem) cvode_mem;
  cvspgmr_mem = (CVSpgmrMem)lmem;
  ier = psolve(N, tn, ycur, fcur, ytemp, gamma, ewt, delta, &nfe, r,
	        lr, P_data, z);
  return(ier);     
}
