'use strict';
/**
 * @license Angular v<unknown>
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
(function (factory) {
    typeof define === 'function' && define.amd ? define(factory) :
        factory();
})((function () {
    'use strict';
    /**
     * @fileoverview
     * @suppress {missingRequire}
     */
    Zone.__load_patch('fetch', function (global, Zone, api) {
        var fetch = global['fetch'];
        if (typeof fetch !== 'function') {
            return;
        }
        var originalFetch = global[api.symbol('fetch')];
        if (originalFetch) {
            // restore unpatched fetch first
            fetch = originalFetch;
        }
        var ZoneAwarePromise = global.Promise;
        var symbolThenPatched = api.symbol('thenPatched');
        var fetchTaskScheduling = api.symbol('fetchTaskScheduling');
        var placeholder = function () { };
        global['fetch'] = function () {
            var _this = this;
            var args = Array.prototype.slice.call(arguments);
            var options = args.length > 1 ? args[1] : {};
            var signal = options && options.signal;
            var ac = new AbortController();
            var fetchSignal = ac.signal;
            options.signal = fetchSignal;
            args[1] = options;
            if (signal) {
                var nativeAddEventListener = signal[Zone.__symbol__('addEventListener')] || signal.addEventListener;
                nativeAddEventListener.call(signal, 'abort', function () {
                    ac.abort();
                }, { once: true });
            }
            return new Promise(function (res, rej) {
                var task = Zone.current.scheduleMacroTask('fetch', placeholder, { fetchArgs: args }, function () {
                    var fetchPromise;
                    var zone = Zone.current;
                    try {
                        zone[fetchTaskScheduling] = true;
                        fetchPromise = fetch.apply(_this, args);
                    }
                    catch (error) {
                        rej(error);
                        return;
                    }
                    finally {
                        zone[fetchTaskScheduling] = false;
                    }
                    if (!(fetchPromise instanceof ZoneAwarePromise)) {
                        var ctor = fetchPromise.constructor;
                        if (!ctor[symbolThenPatched]) {
                            api.patchThen(ctor);
                        }
                    }
                    fetchPromise.then(function (resource) {
                        if (task.state !== 'notScheduled') {
                            task.invoke();
                        }
                        res(resource);
                    }, function (error) {
                        if (task.state !== 'notScheduled') {
                            task.invoke();
                        }
                        rej(error);
                    });
                }, function () {
                    ac.abort();
                });
            });
        };
    });
}));
