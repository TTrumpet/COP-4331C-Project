static void ensureReadable(final ChannelBuffer buf, final int nbytes) {
buf.markReaderIndex();
buf.skipBytes(nbytes); 
buf.resetReaderIndex();
  }@Test
void testCreatePDFA() throws Exception
{
System.out.println("testCreatePDFA");
String pdfaFilename = outDir + "/PDFA.pdf";
String signedPdfaFilename = outDir + "/PDFA_signed.pdf";
String keystorePath = "src/test/resources/org/apache/pdfbox/examples/signature/keystore.p12";
String message = "The quick brown fox jumps over the lazy dog ‰ˆ¸ƒ÷‹ﬂ @∞^≤≥ {[]}";
String dir = "../pdfbox/src/main/resources/org/apache/pdfbox/resources/ttf/";
String fontfile = dir + "LiberationSans-Regular.ttf";
CreatePDFA.main(new String[] { pdfaFilename, message, fontfile });
KeyStore keystore = KeyStore.getInstance("PKCS12");
keystore.load(new FileInputStream(keystorePath), "123456".toCharArray());
CreateSignature signing = new CreateSignature(keystore, "123456".toCharArray());
signing.signDetached(new File(pdfaFilename), new File(signedPdfaFilename));
ValidationResult result = PreflightParser.validate(new File(signedPdfaFilename));
for (ValidationError ve : result.getErrorsList())
{
System.err.println(ve.getErrorCode() + ": " + ve.getDetails());
}
assertTrue(result.isValid(), "PDF file created with CreatePDFA is not valid PDF/A-1b");
try (PDDocument document = Loader.loadPDF(new File(pdfaFilename)))
{
PDDocumentCatalog catalog = document.getDocumentCatalog();
PDMetadata meta = catalog.getMetadata();
DomXmpParser xmpParser = new DomXmpParser();
XMPMetadata metadata = xmpParser.parse(meta.toByteArray());
DublinCoreSchema dc = metadata.getDublinCoreSchema();
assertEquals(pdfaFilename, dc.getTitle());
}
File signedFile = new File(signedPdfaFilename);
BufferedReader br = new BufferedReader(
new InputStreamReader(new FileInputStream(signedFile)));
String line;
boolean isIncrementalArea = false;
Set<String> set = new HashSet<>();
int linePos = 0;
while ((line = br.readLine()) != null)
{
++linePos;
if (line.equals("%%EOF"))
{
isIncrementalArea = true;
set.clear(); 
}
if (!isIncrementalArea)
{
continue;
}
if (line.matches("^\\d+ 0 obj$"))
{
int pos = line.indexOf(" 0 obj");
line = line.substring(0, pos);
assertFalse(set.contains(line), "object '" + line
+ " 0 obj' twice in incremental part of PDF at line " + linePos);
set.add(line);
}
}
br.close();
}@Override
public void delete(Long id) {
log.debug("Request to delete Patient : {}", id);
patientRepository.delete(id);
}@Deprecated
public JsonFactory enable(JsonFactory.Feature f) {
_factoryFeatures |= f.getMask();
return this;
}public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType, @Nullable ConversionService conversionService) {
SingleColumnRowMapper<T> rowMapper = newInstance(requiredType);
rowMapper.setConversionService(conversionService);
return rowMapper;
}private void _writeSegment(int end) throws IOException
{
final int[] escCodes = _outputEscapes;
final int escLen = escCodes.length;
int ptr = 0;
int start = ptr;
output_loop:
while (ptr < end) {
char c;
while (true) {
c = _outputBuffer[ptr];
if (c < escLen && escCodes[c] != 0) {
break;
}
if (++ptr >= end) {
break;
}
}
/* First things first: need to flush the buffer.
 * Inlined, as we don't want to lose tail pointer
 */
int flushLen = (ptr - start);
if (flushLen > 0) {
_writer.write(_outputBuffer, start, flushLen);
if (ptr >= end) {
break output_loop;
}
}
++ptr;
start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCodes[c]);
}
}@SafeVarargs
public static <E> Matcher<Iterable<? extends E>> contains(Matcher<? super E>... itemMatchers) {
final List<Matcher<? super E>> nullSafeWithExplicitTypeMatchers = NullSafety.<E>nullSafe(itemMatchers);
return contains(nullSafeWithExplicitTypeMatchers);
}public void createServiceInstance(ServiceInstance serviceInstance) {
JpaServiceInstance jpaServiceInstance = JpaServiceInstance.builder()
.serviceInstanceId(serviceInstance.getServiceInstanceId())
.serviceId(serviceInstance.getServiceDefinitionId())
.planId(serviceInstance.getPlanId())
.organizationGuid(serviceInstance.getOrganizationGuid())
.spaceGuid(serviceInstance.getSpaceGuid())
.dashboardUrl(serviceInstance.getDashboardUrl())
.build();
jpaServiceInstanceRepository.save(jpaServiceInstance);
}private void handleGenericException(Throwable t) {
println(
String.format(
"SEVERE ERROR: an expected exception occurred: %s with message'%s'",
t.getClass().getName(),
t.getMessage()
)
);
if(debug) {
t.printStackTrace();
}
if(t.getCause() != null) {
println("with cause: '" + t.getCause().getMessage() + "'");
if(debug) {
t.getCause().printStackTrace();
}
 }
}public Instance toInstance() {
DenseInstance ret = new DenseInstance(0.0, centroid);
ret.setWeight(0.0);
ret.setDataset(this.instances);
return ret;
}