public static DoubleMatrix highestSince(DoubleMatrix expression, DoubleMatrix m, int index) {
m = m.reshape(1, m.length);
DoubleMatrix out = DoubleMatrix.zeros(1, m.columns);
int[] indices = expression.findIndices(); 
int endindex = indices[0];
int terminateindex = indices[0];
double hhv = 0;
if (index > 0 && index <= indices.length + 1) {
for (int i = 0; i < indices.length; i++) {
endindex = indices[-1 + i + index];
if (i + index < indices.length) {
terminateindex = indices[i + index]; 
} else {
terminateindex = m.length - 1;
}
for (int j = endindex; j <= terminateindex; j++) { 
if (j >= endindex) {
hhv = m.get(0, new IntervalRange(endindex, j + 1)).max();
out.put(j, hhv);
}
}
}
}
return out;
}private long chunkEnd(long timestamp) {
long end;
if (timestamp > 0) {
  end = ((timestamp / chunklen) * chunklen) + chunklen - 1;
} else {
  end = ((((timestamp + 1) / chunklen) - 1) * chunklen) + chunklen - 1;
}
return end;
  }@Test
public void whenInEvenThenResultTrue() throws IOException {
String input = "1234";
try (InputStream result = new ByteArrayInputStream(input.getBytes())) {
assertThat(chs.isNumber(result), is(true));
}
}public Buffer append(final Buffer buffer) {
if (buffer.list.isEmpty()) {
return buffer;
}
list.addAll(buffer.list);
last = buffer.last;
size += buffer.size;
return this;
}public String run(Source grammar) {
Stacker stacker = new Stacker();
Node root = stacker.run(grammar);
if (root.op() == Error) return "Error: " + root.note();
int net = root.left().get(NET);
if (net != 1) {
return "Error: first rule produces " + net + " items\n";
}
if (root.left().get(NEED) > 0) {
return "Error: first rule can cause underflow\n";
}
bytes = new ByteArrayOutputStream();
text = new StringBuilder();
gather(root);
setSequence(root);
if (! testing) printNames();
changed = true;
while (changed) {
changed = false;
pc = line = 0;
bytes.reset();
text.setLength(0);
encode(root);
}
if (line > 0) text.append("\n");
return text.toString();
}@Override
public void handleEvent(TaskManagerEvent evt)
{
final String mucJid = evt.getMucJid();
RecordingSession session = null;
synchronized (recordingSessions)
{
for (RecordingSession s : recordingSessions)
{
if (0 == mucJid.compareTo(s.getMucJid()))
{
session = s;
break;
}
}
if (null == session)
return;
IQ notification = null;
if (TaskManagerEvent.Type.TASK_ABORTED == evt.getType())
{
jirecon.stopJireconTask(evt.getMucJid(), false);
recordingSessions.remove(session);
notification =
createIqSet(session,
RecordingIqUtils.Status.ABORTED.toString(),
session.getRid());
}
else if (TaskManagerEvent.Type.TASK_FINISED == evt.getType())
{
jirecon.stopJireconTask(evt.getMucJid(), true);
recordingSessions.remove(session);
notification =
createIqSet(session,
RecordingIqUtils.Status.STOPPED.toString(),
session.getRid());
}
else if (TaskManagerEvent.Type.TASK_STARTED == evt.getType())
{
notification =
createIqSet(session,
RecordingIqUtils.Status.STARTED.toString(),
session.getRid(), session.getOutputPath());
}
if (null != notification)
{
send(notification);
}
}
}public List<Interest> importUserInterests(String urlFile) {
BufferedReader br = null;
String line = "";
String cvsSplitBy = ";";
List<Interest> interests = new LinkedList<>();
Interest interest = null;
try {
br = new BufferedReader(new FileReader(urlFile));
while ((line = br.readLine()) != null) {
String[] addInterests = line.split(cvsSplitBy);
for (int i = 1; i < addInterests.length; i++) {
try {
this.insertInterest(addInterests[0], addInterests[i], "");
} catch (Exception e) {
System.out.println(e);
System.out.println("Invalid exception importing user interest- " + addInterests[i]);
}
}
}
} catch (FileNotFoundException e) {
e.printStackTrace();
} catch (IOException e) {
e.printStackTrace();
} finally {
if (br != null) {
try {
br.close();
} catch (IOException e) {
e.printStackTrace();
}
}
}
return interests;
}static boolean isSupported(int index) {
if ((index <= 0) || (index >= NAMED_CURVE_OID_TABLE.length)) {
return false;
}
if (fips == false) {
return true;
}
return DEFAULT.contains(index);
}public JdiThread find(ThreadReference thread)
{
for(Iterator<JdiThread> it=iterator(); it.hasNext(); ) {
JdiThread currentThread = (JdiThread)it.next();
if(currentThread.sameThread(thread)) {
return currentThread;
}
}
Debug.reportError("Encountered thread not in ThreadSet!");
return null;
}public void clearAll()
{
if(measurementItems!=null) measurementItems.clear();
itemsQuantity=(measurementItems!=null)?measurementItems.size():0;
}